Maps are containers that hold elements in a key-value combination, following a specific order. In a map, the key values are
generally used to sort and uniquely identify the elements, while the mapped values store the content associated to this key.
The unique keys are all sorted using a comparison function which can be overwritten by the programmer. The types of key and
mapped value may differ, and are grouped together in member type value_type, which is a pair type combining both:

typedef pair<const Key, T> value_type;


Internally, the elements in a map are always sorted by its key following a specific strict weak ordering criterion indicated by its
internal comparison object (of type Compare). Map containers are generally slower than unordered_map containers to access individual
elements by their key, but they allow the direct iteration on subsets based on their order. The mapped values in a map can be accessed
directly by their corresponding key using the bracket operator ((operator[]).

Maps are typically implemented as binary search trees, also known as red-black tree diagrams.

To construct a map object, there are a couple things you could do. In my header file (13_Map.h), you will see, there is no output of
the function representing these methods. Maps are typically initialized empty, and added onto later, but can have elements inserted 
at contruction. I just prefer to use the first way. Here's the five ways I managed to come up with:

1. std::map<type1, type2> mapName;
2. std::map<type1, type2> mapName (copyMapBeginIteration, copyMapEndIteration);
3. std::map<type1, type2> mapName (copyMap);
4. std::map<type1, type2, comparisonFunction> mapName;
5. std::map<type1, type2, comparisonFunctionPointer> mapName;

All together, there are 28 member functions.

1. std::map::at();

This is the accessor method for maps. It is used to return a reference to the mapped value that has the key input in the parameters.
This function commonly throws errors, so make sure your keys are typed out correctly, case-sensitively. If a key that does not exist
is put into the function parameter list, the function throws the out_of_range exception. This can return a const mapped_type reference
if the map itself is const-qualified. This is a C++11 function, so make sure to compile as C++11 or higher if you are using this. Format:

mapName.at(key);


2. std::map::begin();

Returns an iterator (or const_iterator) that refers to the first element in the map according to the map object's sorting function.
The function takes to parameters. Format:

mapName.begin();


3. std::map::cbegin();

Const version of begin(). Takes no parameters. C++11 function. Format:

mapName.cbegin();


4. std::map::cend();

Const version of end(). Takes no parameters. C++11 function. Format:

mapName.cend();


5. std::map::clear();

Clears and destroys all element keys and values from the map object, effectively clearing up memory. The size of the map becomes 0.
Takes no parameters. Format:

mapName.clear();


6. std::map::count();

This is a very interesting and useful member function of map. Basically, it goes through the entire map, and returns a boolean-like value
based on what exists in the map object. It takes one parameter, being the key you are searching for. If it finds a key that equals your key
input parameter, the function returns an unsigned_int value of 1, otherwise, it returns an unsigned_int value of 0. This is basically just a
boolean, but in integer form. Format:

mapName.count(keyValue);